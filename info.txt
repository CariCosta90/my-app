[Notas del proyecto]


[Componentes funcionales] 
-------------------------

1. Debe tener una funcion y el nombre de la misma debe empezar con mayusculas SIEMPRE

function MiFuncion(){
    return null;
}

const miFuncionFlecha = ()=>{
    return null;
}

Para react es lo mismo usar una u otra al declarar los Componentes.

2. debe importar react
import React from "react";

3. la funcion debe retornar algo, para los componentes funcionales siempre lo va a necesitar

4. se debe exportar la funcion, dado que cada componente estará en un archivo y si no hacemos el export los otros archivos no pueden hacer el uso de ese componente

export default NombreDeFuncion; 

Se usa default solo cuando hay una funcion para exportar, cuando haya mas de una funcion no se puede usar default. Esto es lo ideal dado que lo mejor es que haya un solo componente por archivo.

Cuando se tiene mas de una funcion se pone export adelante de const y se tiene que importar diferente
import {Funcion1, Funcion2, ...} from './App';
Tambien se puede poner que uno vaya por default y el resto entre llaves 
import FuncionPorDefault {otraFuncion, ...} from './App';


5. en los componentes se pueden usar varios padres en un mismo componente, pero se debe ingresar todo dentro de un mismo padre, por ejemplo un div. O un fragment <></> (es como un div fantasma)

6. para que haga los autocompletados de html dentro del Js se tiene que cambiar la extensión a jsx o la otra opcion es seleccionar abajo a la derecha donde dice que lenguaje esta detectando, abre la barra de busqueda, buscar javascript y seleccionar la opcion react

7. para traer imagenes hay que crear una carpeta dentro de src e importarla en el componente

8. MUI - componentes e iconos prearmados (libreria), primero se tiene que instalar desde la pag mui.com // para usar los iconos tambien hay que instalar (npm install @mui/icons-material)

[COMPONENTES de clase]
----------------------

2 TIPOS 
''''''''
funcionales y de clase. Hoy por hoy se usan poco los componentes de clase. 

- props
- states
- ciclos de vida
- metodos de ciclos de vida

const MiFuncion = (parametro) => {
    mi bloque de codigo
}

function MiFuncion(parametro){
    mi bloque de codigo
}


            [Props]
            -------

los props se pueden pasar de padre a hijo pero no al revez, entonces en este ejemplo, en App.js le podemos pasar props a header.js
Los props que se traen en el componente padre, se llaman como parametros en el componente hijo con "props" entre los parentesis de la funcion y lo va a traer como un objeto.

se puede aplicar destructuring y en vez de traer props entre parentesis poner ({prop1, prop2, ...}) para despues usarlo así mismo 

ej: 

en apps se declaran las props:

--> en este caso se estan declarando como constantes o hardcodeado, pero la idea es que eventualmente se pasen props de interaccion con el usuario, supongo que eventos, inputs, etc.


const nombre = "Alejandro"; 
    return (
    <>
    {/* asi se le pasan las props al componente */}
    <Header nombreUsuario={nombre}  apellidoUsuario="Fernandez" />
    )


--> y luego en el componente Header:

export const Header = ({nombreUsuario, apellidoUsuario})=>{
--> alternativa a const Header = (props) y const {nombreUsuario,apellidoUsuario} =props;


    return (
        <header>
            <img src={logo} alt="logo de tienda" />
            <h1>Nombre de la Tienda</h1>
            {/* esto despues se puede hacer en componente */}
            <nav>
                <a href="google.com">Categoría 1 </a>
                <a href="google.com">Categoría 2 </a>
                <a href="google.com">Categoría 3 </a>
                <a href="google.com">Categoría 4 </a>
            </nav>
            <p>Bienvenido {nombreUsuario}{apellidoUsuario}</p>
            <ShoppingCartIcon color="primary" fontSize="large" className="cart"/>
        </header>
    );
};

1. si se no se usa el desestructuring despues se tiene que llamar la props con el props. adelante (esa palabra puede ser cualquiera no tiene que ser props)

2. para usar JS dentro del jsx, donde se esta llamando al html siempre se tiene que usar { } las llaves son el escape del html y llamada o uso del JS. 

3. las props siempre son un objeto, por eso se llama "objeto.propiedad"

destructuring:
-------------

cuando tenemos un array y queremos usarlo con los valores por separado:

const array = [1,2,3];

--> se puede hacer:

const uno = array[0]
const dos = array[1]
const tres = array[2]

o 

--> podemos hacer:

const [uno, dos, tres] = array

destructuring para objetos:
--------------------------

const objeto = {
    x:1,
    y:2,
}

--> se puede hacer:

const a = objeto.x
const b = objeto.y

--> o se puede hacer:

const (a:x, b:y ) = objeto --> lo que esta en x asignaselo a la variable a y lo que esta en y asignaselo a la variable b

object property shorthand, en los objetos si el nombre de lo que estoy asignando es el mismo que el nombre del valor, se puede escribir de forma reducida. Ej:

A. forma 1

var name = 'John Doe';
var email = 'john.doe@example.com';
var age = 25;

var user = {
    name: name,
    email: email,
    age: age
};

B. forma 2

let name = 'John Doe';
let email = 'john.doe@example.com';
let age = 25;

let user = { name, email, age };

console.log(user);

// { 
//     name: 'John Doe', 
//     email: 'john.doe@example.com', 
//     age: 25 
// }

tambien se pueden combinar ambos

C. forma 3 

let user = { name, userEmail: email, age };

// { 
//     name: 'John Doe', 
//     userEmail: 'john.doe@example.com', 
//     age: 25 
// }



Por props se pueden pasar componentes:
-------------------------------------

1. creacion de componente titulo para probar
2. creacion do componente titulo

estos dos componentes los importe en apps, pero no los voy a usar alli, los voy a pasar por props a navBar para que los use. 

??????? esto no se puede hacer directo de los nuevos componentes creados? por que no???????

para pasar estos props especiales que son componentes completos, la llamada a navBar en apps se crea una etiqueta de cierre para el componente y dentro de la etiqueta completa se llaman los componentes. 

<Header nombreUsuario={nombre}  apellidoUsuario="Fernandez">
<ComponenteBoton/>
<ComponenteTitulo/>
</Header>

estos pasan a ser componentes children no dejan de ser props. 

se llaman desde el otro componente con la palabra reservada children

export const Header = ({nombreUsuario, apellidoUsuario, children})=>{
                                                        ''''''''
        return (
            <header>
                <p>Bienvenido {nombreUsuario}{apellidoUsuario}</p>
                {children}
                ''''''''''
                <ShoppingCartIcon color="primary" fontSize="large" className="cart"/>
            </header>
        );
    };

si los quiero pasar solo uno o por separado 
{children[0]}
{children[1]}


                                - MAP
                                ''''''

ahora vamos a ver con el map como mostrar el listado de categorias 
para esto creamos las categorias como objeto 

const categorias = [
    {nombre : "Caregoria 1", id: 0, ruta: ""},
    {nombre : "Caregoria 2", id: 1, ruta: ""},
    {nombre : "Caregoria 3", id: 2, ruta: ""},
    {nombre : "Caregoria 4", id: 3, ruta: ""},
];

ESTO NO ME QUEDA TAN CLARO POR QUE ES! (lo siguiente)

para poder iterar por ese array de objetos se usa un map porque un forEach no retorna nada, porque no es una expesion (que quiere decir con que no retorna nada? y entonces que hace?)

en el jsx solo se pueden usar expresiones. y donde se usan los foe each y demas??? no entiendo 

categorias.map((categoria)=> {
    return <a key={categoria.id} href={categoria.ruta}>{categoria.nombre}</a>
})

Los mapas siempre necesitan una key, por lo cual es importante que la lista de objetos tenga id 

Si por algun motivo la lista no tiene id: ahi se puede agregar el indice a la funcion del map 

categorias.map((categoria, i)=> {
                        ''''''
    return <a key={i} href={categoria.ruta}>{categoria.nombre}</a>
                ''''''
})



[COMPONENTES II]
''''''''''''''''

- STATES
''''''''

Un estado de react es una variable que al modificarse genera una actualizacion en el componente
que significa? que se vuelve a ejecutar el componente. 

Trabajamos sobro componenteEstados

Inroduccion a eventos, para react se usa el OnEvento dentro del html. 

- como se hacia en JS?
variable.addEventListener("click", callback);
const callback = ()=>{
    codigo a ejecutar
}

- como se hace en react?

<button onClick={handleClick}>click</button>

const handleClick = ()=>{
    codigo a ejecutar
}

1. [HOOKS]
''''''''''

cuando se ejecta el jsx despues no le presta atencion de nuevo, despues de que esta definido, si queremos tener variables que generen dinamismo, para esto se usan los estados. Para esto usamos los [hooks]. Son funcionalidades prearmadas que utilizamos dentro de los componentes funcionales para multiples cosas. Es para pexcar funcionalidades. 
- Se identifica un hook porque inicia con la palabra Use
- Siempre se declaran dentro del componente
- No se pueden declarar de forma condicional
- Son siempre funciones
https://es.reactjs.org/docs/hooks-reference.html

Hooks básicos
''''''''''''''

useState
useEffect
useContext

[useState]
''''''''''
const [state, setState] = useState(initialState);

[Devuelve un valor con estado y una función para actualizarlo.]

Durante el renderizado inicial, el estado devuelto (state) es el mismo que el valor pasado como primer argumento (initialState).

La función setState se usa para actualizar el estado. Acepta un nuevo valor de estado y sitúa en la cola una nueva renderización del componente.

setState(newState);

En las renderizaciones siguientes, el primer valor devuelto por useState será siempre el estado más reciente después de aplicar las actualizaciones.

--> hay que importarlo  
import React, {useState} from 'react'

- --> como se declara? 

const [contador, setContador] = useState();

Los estados de react no se modifican de forma directa, lo que se tiene que usar es el seter, esto quiere decir que para manipular el cambio se debe usar (en este ejemplo) setContador, no se debe editar nunca "contador" en si mismo.

- Definicion inicial de los estados:

con los estados pasa lo mismo que en las variables, si lo pongo sin nada (useState()) inicia como undefined, pero ahi mismo ya puedo ponerle un valor inicial ej (useState(2) inicia en 2).

ej:

si yo quiero que contador aumente de 1 en 1:

dentro del callback del evento --> setContador(contador+1);

un use state siempre devuelve un array de 2 cosas:
1. el propio estado
2. una funcion getter para modificarlo

no se puede usar push al querer agregar mas valores a un array en los estados de react.

como se hace una copia de un array? 
no se puede hacer   const copia = usuarios; dado que el = es un puntero lo cual quiere decir que terminan apuntando al mismo espacio de memoria, se reasigna en vez de generar una copia real. 

para crear una copia se tiene que utilizar el spread. 
entonces seria const copia = [...usuarios];

ej:

const [usuarios, setUsuarios]= useState([
    {nombre:"Nicolas"}, 
    {nombre:"Pedro"},
]);

const mariano = {nombre:"mariano"};
const agregarMariano = ()=>{
    setUsuarios([...usuarios, mariano]);
}

[CICLO DE VIDA Y METODOS]

- Montaje(mount)
    - constructor --> pasar la data, todo lo que esta antes del return
    - render --> la parte de mostrar, todo lo que esta dentro del return
    -  componentDidMount, se suelen ejecutar aqui consultas, agentes terceros, busqueda de informacion, operaciones que el componente necesita. Ej. si depende de la informacion de una api. 

-Actualizacion(Update)
    - constructor
    - render
    - componentDidUpdate. este se ejecuta cuando el componente se actualiza es la unica diferencia con el anterior

-Desmontaje(unmount)
    - componentWillUnmount. es un componente que se monta cuando el componente se esta desmontando.(??). 


**que es el UseEffect?** --> buscar

(demostraciones en componente)

- controlador de cambios de estado

se ejecuta solo en el montaje

useEffect(()=>{
    bloque de codigo
},[])

no devuelve nada, lo que si hace es recibir 2 parametros:

1. una funcion flecha 
2. un array

se ejecuta al montaje y cuando detecta cambios en los valores del array de dependencia

useEffect(()=>{
    bloque de codigo
},[valores])

el useEffect hace manipulaciones del estado sin generar bucles.


con esta configuracion se ejecuta en el montaje y en actualizaciones

useEffect(()=>{
    bloque de codigo
},[])

si hacemos manipulacion de estado dentro del useEffect generamos un loop infinito porque corre constructor, corre render y despues useEffect, se actualiza e inicia todo de nuevo.

array de control.
se usa para definir que se corra use effect, cuando se monta (siempre, inevitable) y luego se ejecuta cuando cambie lo que se puso en ese array.
Si se deja el array vacio se ejecuta solo al principio una vez. 

ej en componenteEstados:

const [numero, setNumero] = useState(0);

useEffect(()=>{
    console.log("se ejecuta useEffect");
    setNumero (numero + 1)
},[contador]);

en este caso por ejemplo se correra el codigo al momento del montaje y luego cada vez que lo contenido dentro del array de control cambie, en este caso el contador. 


Repaso de JS importante:
setTimeout toma 2 cosas, una funcion flecha y un numero en milisegondos. 
Sirve para correr una funcion pero con el delay indicado (2000 serian 2 segundos)

setTimeout((=>{
    console.log('ejemplo')
}, 2000))

setinterval

recibo una funcion y un numero en milisegundos
es casi lo mismo pero este espera ejecuta y espera ejecuta
el setInterval es como un bucle de tiempo en repeticion  mientras el setTimeout, espera y corre una sola vez.

setInterval(()=>{}, 2000)

que son expresiones?? [BUSCAR] --> es algo que devuelve algo? como un if no devuelve nada? no entiendo. Un ternario tiene un return implicito.

para matar el setInterval hay que agregar un return dentro del mismo useEffect, sino cada vez que se monta y se desmonta genera un nuevo setInterval

const intervalo = setInterval (()=> {
    console.log('ping');
}, 1000) // esto gener aun log de ping cada un segundo, cada vez que le doy al boton alternar genera uno nuevo

return (()=>{
    clearInterval(intervalo)
})
(no estoy segura de para que crearia un intervalo para luego matarlo)

viendo la clase lo que hace es matar el interval cuando se va el componente, y cuando vuelvo a cargar el componente inicia de nuevo el setInterval

esto es el componentWillUnmount

[PROMISES Y ASYNC]

ItemListContainer.js

en el front habitualmente no se crean promesas, se consumen. 

const promesa = new Promise((resolve,reject)=>{
    resolve("Respuesta positiva");
    reject("ocurrio un error en la promesa")
})

una promesa es algo que no se puede manipular en el tiempo. Es el formato para trabajar de forma asicrona, cuando llamaremos cosas que pueden llevar tiempo. 

para consumir promeras se hace dentro del useEffect. 
(el useEffect se tiene que importar de react)

el catch se efectua cuando falla la respuesta de la promesa (para probar lo hacemos comentando el resolve)

useEffect(()=>{
    promesa
    .then((data)=>{
        console.log("salio todo bien");
        console.log(data); --> este data seria lo que viene del resolve de la decalaracion de la promesa
    })
    .catch((e)=>{
        console.log("salio todo mal");
        console.log(e); --> el e (o error) trae lo del reject de la declaracion de la promesa
    })
    .finally(()=>{
        console.log("termino la ejecucion")
    }) --> opcional y se ejecutaria cada vez, por ejemplo si tengo que hacer algo sin importar la respuesta
},[])




clase del 12 / 10
[EVENTOS]

ComponenteEventos

// en vanilla
const callback = ()=>{
    console.log("click");
}
const unElemento = document.getElementById("id");
unElemento.addEventListener("click", callback)


en react se usa el onEvento (ej. onClick) inline

en el callback del evento no se pone parentesis 
si se necesita pasarle parametros se genera la funcion flecha

const callback = (mensaje)=>{
    console.log(mensaje);
}

<button onClick={()=>callback("hola mensaje")}>Click</button>

los eventos se propagan de hijo a padre al revez de las props. 
esto quiere decir que si hay un onclick en un boton y ese boton esta dentro de un div y el div tiene un onclick, al accionar el boton se ejecutaran ambos, el del hijo y el del padre. Siendo el mismo tipo de evento. [Esto es el efecto burbuja.]

para evitar esto se puede usar el event.stopPropagation();


const callback = (event)=>{
    console.log("click");
    event.stopPropagation();
}

si queremos obtener el objeto del evento o el valor del evento:

const callback = (event)=>{
    console.dir(event.target);
    console.log(event.target.value);
}

Seguimos en Users.js y UserList.js

Users gestiona la logica de agregar los elementos a la lista 
y UserList gestiona el mostrarlos en componente

como hago si quiero borrar elementos de la lista? 

filter inverso

const array = [1,2,3,4,5]
const arrayFiltrado = array.filter((numer)=>{
    return numero !== 3
})

trae todo menos 3 y guarda el array con eso

en este caso lo hicimos con el valor (nombre) pero seria ideal usar un id porque sino si se repite un nombre lo va a borrar todos
